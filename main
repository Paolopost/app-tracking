#!/bin/bash

#PBS -l nodes=1:ppn=8
#PBS -l walltime=12:00:00
#PBS -N tracking
#PBS -V

module load mrtrix/0.2.12
module load freesurfer
module load matlab
module load python

set -x
set -e

dwi=`jq -r '.dwi' config.json`
if [ $dwi != "null" ]; then
    export input_nii_gz=$dwi
    export BVECS=`jq -r '.bvecs' config.json`
    export BVALS=`jq -r '.bvals' config.json`
fi
dtiinit=`jq -r '.dtiinit' config.json`
if [ $dtiinit != "null" ]; then
    export input_nii_gz=$dtiinit/`jq -r '.files.alignedDwRaw' $dtiinit/dt6.json`
    export BVECS=$dtiinit/`jq -r '.files.alignedDwBvecs' $dtiinit/dt6.json`
    export BVALS=$dtiinit/`jq -r '.files.alignedDwBvals' $dtiinit/dt6.json`
fi

NUMFIBERS=`jq -r '.fibers' config.json`
MAXNUMFIBERSATTEMPTED=`jq -r '.fibers_max' config.json`
LMAX=`jq -r '.lmax' config.json`

#TODO - validate other fields?
if [[ $LMAX == "null" || -z $LMAX ]]; then
    echo "lmax is empty.. calculating max lmax to use from $BVALS"
	LMAX=`./calculatelmax.py $BVALS`
fi
echo "Using LMAX: $LMAX"

#load bvals/bvecs
bvals=$(cat $BVALS | tr ',' ' ')
bvecs_x=$(cat $BVECS | tr ',' ' ' | head -1)
bvecs_y=$(cat $BVECS | tr ',' ' ' | head -2 | tail -1)
bvecs_z=$(cat $BVECS | tr ',' ' ' | tail -1)

#convert strings to array of numbers
bvecs_x=($bvecs_x)
bvecs_y=($bvecs_y)
bvecs_z=($bvecs_z)

#output grad.b
i=0
true > grad.b
for bval in $bvals; do
    echo ${bvecs_x[$i]} ${bvecs_y[$i]} ${bvecs_z[$i]} $bval >> grad.b
    i=$((i+1))
done

echo "starting matlab to create wm.nii.gz"
if [ ! -f wm.nii.gz ]; then
    time matlab -nodisplay -nosplash -r make_wm_mask
fi

echo "converting wm.nii.gz to wm.mif"
if [ ! -f wm.mif ]; then
    time mrconvert --quiet wm.nii.gz wm.mif
fi

echo "converting dwi input to mif (should take a few minutes)"
if [ ! -f dwi.mif ]; then
    time mrconvert --quiet $input_nii_gz dwi.mif
fi

###################################################################################################

echo "make brainmask from dwi data (about 18 minutes)"
if [ ! -f brainmask.mif ]; then
    time average -quiet dwi.mif -axis 3 - | threshold -quiet - - | median3D -quiet - - | median3D -quiet - brainmask.mif
fi

###################################################################################################

echo "dwi2tensor"
if [ ! -f dt.mif ]; then
    time dwi2tensor -quiet dwi.mif -grad grad.b dt.mif 
fi

echo "tensor2FA"
if [ ! -f fa.mif ]; then
    time tensor2FA -quiet dt.mif - | mrmult -quiet - brainmask.mif fa.mif
fi

echo "erode"
if [ ! -f sf.mif ]; then
    time erode -quiet brainmask.mif -npass 3 - | mrmult -quiet fa.mif - - | threshold -quiet - -abs 0.7 sf.mif
fi

echo "estimate response function"
if [ ! -f response.txt ]; then
    time estimate_response -quiet dwi.mif sf.mif -grad grad.b response.txt
fi

echo "generating DT_STREAM"
#mrtrix doc says streamtrack/DT_STREAM doesn't need grad.. but without it, it fails
time streamtrack -quiet DT_STREAM dwi.mif output.DT_STREAM.tck -seed wm.mif -mask wm.mif -grad grad.b -number $NUMFIBERS -maxnum $MAXNUMFIBERSATTEMPTED

# SD_PROB and SD_STREAM uses CSD lmax.N.mif (aka FOD?) (should take about 10 minutes to several hours - depending on lmax value) 
echo "computing lmax"
if [ ! -f lmax.mif ]; then
    time csdeconv -quiet dwi.mif -grad grad.b response.txt -lmax $LMAX -mask brainmask.mif lmax.mif
fi

echo "generating SD_STREAM"
time streamtrack -quiet SD_STREAM lmax.mif output.SD_STREAM.tck -seed wm.mif -mask wm.mif -grad grad.b -number $NUMFIBERS -maxnum $MAXNUMFIBERSATTEMPTED

echo "generating SD_PROB"
time streamtrack -quiet SD_PROB lmax.mif output.SD_PROB.tck -seed wm.mif -mask wm.mif -grad grad.b -number $NUMFIBERS -maxnum $MAXNUMFIBERSATTEMPTED

echo "creating neuro/dwi/recon datatype"
mrconvert lmax.mif csd.nii.gz
mrconvert fa.mif fa.nii.gz
mrconvert dt.mif dt.nii.gz
mrconvert wm.mif whitematter.nii.gz
mrconvert brainmask.mif brainmask.nii.gz

echo "gathering infor for product.json"
track_info output.SD_PROB.tck | ./info2json.py > SD_PROB.json
track_info output.SD_STREAM.tck | ./info2json.py > SD_STREAM.json
track_info output.DT_STREAM.tck | ./info2json.py > DT_STREAM.json
./pull_form.py $(jq -r .dwi config.json) > forms.json

echo "writing product.json"
cat << EOF > product.json
{
    "brainlife": [
        {
            "type": "dataset",
            "id": "dt_stream",
            "meta": {
                "qform": $(jq .qform forms.json),
                "sform": $(jq .sform forms.json),
                "TractographyClass": "local",
                "TractographyMethod": "deterministic",
                "StepSizeUnits": "mm",
                "StepSize": $(jq -r .step_size DT_STREAM.json),
                "AngleCurvature": $(jq -r .min_curv DT_STREAM.json),
                "SeedingMethod": "globalSeedNumber",
                "SeedingNumberMethod": "totalStreamlinesNumber",
                "TerminationCriterion": "leaveMask",
                "TerminationCriterionTest": "binary"
            }
        },

        {
            "type": "dataset",
            "id": "sd_stream",
            "meta": {
                "qform": $(jq .qform forms.json),
                "sform": $(jq .sform forms.json),
                "TractographyClass": "local",
                "TractographyMethod": "deterministic",
                "StepSizeUnits": "mm",
                "StepSize": $(jq -r .step_size SD_STREAM.json),
                "AngleCurvature": $(jq -r .min_curv SD_STREAM.json),
                "SeedingMethod": "globalSeedNumber",
                "SeedingNumberMethod": "totalStreamlinesNumber",
                "TerminationCriterion": "leaveMask",
                "TerminationCriterionTest": "binary"
            }
        },

        {
            "type": "dataset",
            "id": "sd_prob",
            "meta": {
                "qform": $(jq .qform forms.json),
                "sform": $(jq .sform forms.json),
                "TractographyClass": "local",
                "TractographyMethod": "probabilistic",
                "StepSizeUnits": "mm",
                "StepSize": $(jq -r .step_size SD_PROB.json),
                "AngleCurvature": $(jq -r .min_curv SD_PROB.json),
                "SeedingMethod": "globalSeedNumber",
                "SeedingNumberMethod": "totalStreamlinesNumber",
                "TerminationCriterion": "leaveMask",
                "TerminationCriterionTest": "binary"
            }
        }
    ],

    "track_info": {
        "dt_stream": $(jq . DT_STREAM.json),
        "sd_stream": $(jq . SD_STREAM.json),
        "sd_prob": $(jq . SD_PROB.json)
    }
}
EOF

echo "all done"

